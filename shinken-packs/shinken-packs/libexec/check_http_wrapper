#!/bin/sh

# Copyright: 2013 Francois Lafont <francois.lafont@crdp.ac-versailles.fr>
#
# License: GPL-3.0+
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

export LC_ALL=C
SCRIPT_NAME=${0##*/}
UNKNOWN=3
OPTIONS_LIST="ssl,ip-address:,url:,regex:,warning:,critical:,timeout:,plugin-http:,certificate:,onredirect:"

if ! TEMP=$(getopt -o "" -l "$OPTIONS_LIST" -n "$SCRIPT_NAME" -- "$@")
then
    echo "Syntax error with $SCRIPT_NAME command." >&2
    exit 3
fi

eval set -- "$TEMP"
unset TEMP

# Default values of some options.
warning="3"
critical="7"
timeout="10"
plugin_http="/usr/lib/nagios/plugins/check_http"
onredirect="ok"

while true
do
    case "$1" in

        --ssl)
            ssl="--ssl"
            shift 1
        ;;

        --ip-address)
            ip_address="$2"
            shift 2
        ;;

        --url)
            url="$2"

            # Cut url to have <host>:<port>:<path>
            array=$(echo "$url" | sed -nr 's;^([-a-zA-Z0-9_.]+)(:([0-9]+))?(/.*)?$;\1:\3:\4;p')

            if [ -z "$array" ]
            then
                echo "Bad syntax in the url."
                exit "$UNKNOWN"
            fi

            host=$(echo "$array" | cut -d':' -f 1)
            port=$(echo "$array" | cut -d':' -f 2)
            path=$(echo "$array" | cut -d':' -f 3)

            shift 2
        ;;

        --regex)
            regex="$2"
            shift 2
        ;;

        --warning)
            warning="$2"
            shift 2
        ;;

        --critical)
            critical="$2"
            shift 2
        ;;

        --timeout)
            timeout="$2"
            shift 2
        ;;

        --plugin-http)
            plugin_http="$2"
            shift 2
        ;;

        --certificate)
            certificate="$2"
            ssl="--ssl" # The --ssl option is automatically enabled in this case.
            shift 2
        ;;

        --onredirect)
            onredirect="$2"
            shift 2
        ;;

        --)
            shift 1
            break
        ;;

    esac
done

# The --url option is mandatory.
if [ -z "$url" ]
then
    echo "Sorry, the --url option is mandatory."
    exit "$UNKNOWN"
fi

# Default value of port if the variable is empty.
if [ -z "$port" ]
then
    if [ -z "$ssl" ]
    then
        # If no ssl, 80 is the default port.
        port='80'
    else
        port='443'
    fi
fi

# Default value of ip_address if the variable is empty.
if [ -z "$ip_address" ]
then
    ip_address="$host"
fi

# Case when we just want to check the certificate.
if [ -n "$certificate" ]
then
    # The --sni option enables "SSL/TLS hostname extension support"
    # which allows to check the certificate according to the vhost.
    "$plugin_http" "$ssl" -4 -I "$ip_address" -H "$host" --sni -p "$port" \
        -C "$certificate" --timeout="$timeout"; exit "$?"
fi

# Default value of path if the variable is empty.
if [ -z "$path" ]
then
    path='/'
fi

# In the code below:
#   - '-I' option is the address (IP or fqdn) of the destination server
#   - '-H' option is the host header in the http[s] request, ie the
#     requested virtual host.

if [ -z "$regex" ]
then
    "$plugin_http" "$ssl" -4 -I "$ip_address" -H "$host" -u "$path" \
        -p "$port" -w "$warning" -c "$critical" --timeout="$timeout" --onredirect="$onredirect"
else
    # There is a regex.
    # If the exit code is not OK and if the pattern is not found,
    # there is a specific output.
    output=$("$plugin_http" "$ssl" -4 -I "$ip_address" -H "$host" -u "$path" --regex "$regex" \
                  -p "$port" -w "$warning" -c "$critical" --timeout="$timeout"                \
                  --onredirect="$onredirect" 2>&1); exit_code="$?"

    if [ "$exit_code" = "0" ]
    then
        echo "$output"
        exit "$exit_code"
    fi

    if echo "$output" | grep -q 'pattern not found'
    then
        perfdata=$(echo "$output" | sed -r "s/^.*\|(.*)$/\1/")
        output="Response from host which does NOT contain this pattern --> $regex |$perfdata"
    fi

    echo "$output"
    exit "$exit_code"

fi


