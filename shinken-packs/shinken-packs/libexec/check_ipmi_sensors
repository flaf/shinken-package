#!/bin/sh

SCRIPT_NAME=${0##*/}
SCRIPT_DIRECTORY=${0%/*}
SPECIFIC_SHORT_OPTIONS=''
SPECIFIC_LONG_OPTIONS=''
SPECIFIC_SYNOPSIS=''

GET_SPECIFIC_OPTIONS () {
    return 0
}

. "$SCRIPT_DIRECTORY/share/snmp.sh"

# The oid 'NET-SNMP-EXTEND-MIB::nsExtendOutputFull."get_ipmi_status"' in text format.
oid='.1.3.6.1.4.1.8072.1.3.2.3.1.2.15.103.101.116.95.105.112.109.105.95.115.116.97.116.117.115'

old_IFS=$IFS
LINE_FEED='
'

# Getting of the host uptime.
if output=$(snmpget $SNMP_CMD_OPTIONS -OvQ "$HOSTNAME" "$oid" 2>&1)
then

    # Remove leading double quotes.
    output=$(echo "${output#\"}")
    output=$(echo "${output%\"}")

    if ! echo "$output" | head -n 1 | grep -q '^ID,Name,Type,State,Event$'
    then
        # The output is incorrect (unlikely when the "snmpget" command has succeeded).
        echo "Unexpected output in the snmpget request: \"$output\""
        exit "$CODE_UNKNOWN"
    fi

    # Remove header.
    output=$(echo "$output" | sed -n '1!p')

    all_is_ok=true
    list=''

    IFS="$LINE_FEED"
    for line in $output
    do
        name=$(echo "$line" | cut -d',' -f2 | tr ' ' '_')
        state=$(echo "$line" | cut -d',' -f'4')
        [ "$state" = 'Nominal' ] && state=OK # "OK" is more explicit
        list="$list $name=$state"

        [ "$state" != 'OK' ] && all_is_ok=false

    done
    IFS="$old_IFS"

    list=$(echo $list)

    if "$all_is_ok"
    then
        echo "IPMI sensors OK: $list."
        exit "$CODE_OK"
    else
        echo "IPMI sensors WARNING: $list."
        exit "$CODE_WARNING"
    fi

else

    # The "snmpget" command hasn't succeeded.
    echo "$output"
    exit "$CODE_UNKNOWN"

fi


